function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useCallback, useEffect, useMemo, useRef } from 'react';
import TextInput from '../TextInput';
import Box from '../Box';
import Flex from '../Flex';
import { ActionList } from '../ActionList';
import Spinner from '../Spinner';
import { useFocusZone } from '../hooks/useFocusZone';
import { uniqueId } from '../utils/uniqueId';
import { itemActiveDescendantClass } from '../ActionList/Item';
import { useProvidedStateOrCreate } from '../hooks/useProvidedStateOrCreate';
import styled from 'styled-components';
import { get } from '../constants';
import useScrollFlash from '../hooks/useScrollFlash';

function scrollIntoViewingArea(child, container, margin = 8, behavior = 'smooth') {
  const {
    top: childTop,
    bottom: childBottom
  } = child.getBoundingClientRect();
  const {
    top: containerTop,
    bottom: containerBottom
  } = container.getBoundingClientRect();
  const isChildTopAboveViewingArea = childTop < containerTop + margin;
  const isChildBottomBelowViewingArea = childBottom > containerBottom - margin;

  if (isChildTopAboveViewingArea) {
    const scrollHeightToChildTop = childTop - containerTop + container.scrollTop;
    container.scrollTo({
      behavior,
      top: scrollHeightToChildTop - margin
    });
  } else if (isChildBottomBelowViewingArea) {
    const scrollHeightToChildBottom = childBottom - containerBottom + container.scrollTop;
    container.scrollTo({
      behavior,
      top: scrollHeightToChildBottom + margin
    });
  } // either completely in view or outside viewing area on both ends, don't scroll

}

const StyledHeader = styled.div.withConfig({
  displayName: "FilteredActionList__StyledHeader",
  componentId: "yg3jkv-0"
})(["box-shadow:0 1px 0 ", ";z-index:1;"], get('colors.border.primary'));
export function FilteredActionList({
  loading = false,
  placeholderText,
  filterValue: externalFilterValue,
  onFilterChange,
  items,
  textInputProps,
  ...listProps
}) {
  const [filterValue, setInternalFilterValue] = useProvidedStateOrCreate(externalFilterValue, undefined, '');
  const onInputChange = useCallback(e => {
    const value = e.target.value;
    onFilterChange(value, e);
    setInternalFilterValue(value);
  }, [onFilterChange, setInternalFilterValue]);
  const containerRef = useRef(null);
  const scrollContainerRef = useRef(null);
  const inputRef = useRef(null);
  const activeDescendantRef = useRef();
  const listId = useMemo(uniqueId, []);
  const onInputKeyPress = useCallback(event => {
    if (event.key === 'Enter' && activeDescendantRef.current) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation(); // Forward Enter key press to active descendant so that item gets activated

      const activeDescendantEvent = new KeyboardEvent(event.type, event.nativeEvent);
      activeDescendantRef.current.dispatchEvent(activeDescendantEvent);
    }
  }, [activeDescendantRef]);
  useFocusZone({
    containerRef,
    focusOutBehavior: 'wrap',
    focusableElementFilter: element => {
      if (element instanceof HTMLInputElement) {
        // No active-descendant focus on checkboxes in list items or filter input
        return false;
      }

      return true;
    },
    activeDescendantFocus: inputRef,
    onActiveDescendantChanged: (current, previous) => {
      activeDescendantRef.current = current;

      if (previous) {
        previous.classList.remove(itemActiveDescendantClass);
      }

      if (current) {
        current.classList.add(itemActiveDescendantClass);

        if (scrollContainerRef.current) {
          scrollIntoViewingArea(current, scrollContainerRef.current);
        }
      }
    }
  });
  useEffect(() => {
    // if items changed, we want to instantly move active descendant into view
    if (activeDescendantRef.current && scrollContainerRef.current) {
      scrollIntoViewingArea(activeDescendantRef.current, scrollContainerRef.current, undefined, 'auto');
    }
  }, [items]);
  useScrollFlash(scrollContainerRef);
  return /*#__PURE__*/React.createElement(Flex, {
    ref: containerRef,
    flexDirection: "column",
    overflow: "hidden"
  }, /*#__PURE__*/React.createElement(StyledHeader, null, /*#__PURE__*/React.createElement(TextInput, _extends({
    ref: inputRef,
    block: true,
    width: "auto",
    color: "text.primary",
    value: filterValue,
    onChange: onInputChange,
    onKeyPress: onInputKeyPress,
    placeholder: placeholderText,
    "aria-label": placeholderText,
    "aria-controls": listId
  }, textInputProps))), /*#__PURE__*/React.createElement(Box, {
    ref: scrollContainerRef,
    overflow: "auto"
  }, loading ? /*#__PURE__*/React.createElement(Box, {
    width: "100%",
    display: "flex",
    flexDirection: "row",
    justifyContent: "center",
    pt: 6,
    pb: 7
  }, /*#__PURE__*/React.createElement(Spinner, null)) : /*#__PURE__*/React.createElement(ActionList, _extends({
    items: items
  }, listProps, {
    role: "listbox",
    id: listId
  }))));
}
FilteredActionList.displayName = "FilteredActionList";
FilteredActionList.displayName = 'FilteredActionList';